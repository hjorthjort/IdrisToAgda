% CREATED BY DAVID FRISK, 2016
\chapter{Methods}

The first step is to translate simple declarations of types and functions,
without dependent types. A subset roughly corresponding to Simply Typed Lambda
Calculus. Since dependent types are the focus of the project the next step is
to translate them. Starting with application in the type level, and functions
definitions. Continuing with indexed data types.
Both Idris and Agda are large languages, some features are more important to
implement then other.  For example \texttt{mutual}-blocks and
\texttt{do}-notation. They are de-sugared in the Idris compiler so are not
strictly necessary to implement. However correctly translating them will
increase the readability and the usefulness of the generated code.
% TODO Talk about the type language.
% type lang
% base types
% variable
% application t1 t2
% function definition (x : t1) -> t2

% Sum/ simple enumeration T | F
% prod/data P = P Bool Bool

% Indexerad data typer

% Kriteriet for att oversatta eller inte ar inte om det ar latt eller
% svart. Both Idris and Agda are large languages. What features are most
% important to translate?

% Developing from the Idris 1 or Blodwen codebase, utilizing as much of the AST
% and pretty printer from the Agda-source as possible.

We wish to reuse the Idris complier front-end for our implementation, by
implementing the translator as a back-end. Hopefully we can reuse the abstract
syntax tree (AST) definition and pretty-printer from the Agda implementation as
well. This means that most of the code needed is handling the actual
translation, minimizing work needed on surrounding infrastructure.  However,
there is always a challenge to interface with existing code.

% | Below is stated elsewhere.
% Another hard task is to find the biggest common subset of the languages.
% It is trivial to name a few common features, bu a useful compiler needs to
% support most widely used features. But there are incompatible differences
% between Agda and Idris which complicates things.

Working step by step, we first translate only very simple programs, then adding
more and more features. Currently unimplemented features are represented with
holes so that it is always possible to translate code. The output becomes more
and more complete as the project progresses. The number of holes left for
a given project also works as an informal method of verification, less holes
corresponds to a better translator.

To test the implementation we will use the Sequential Decision Problem (SDP)
implementation in
IdrisLibs\footnote{\url{https://gitlab.pik-potsdam.de/botta/IdrisLibs}} which
is one of the bigger Idris codebases available. This will guide our
implementation by first supporting the features used in the core parts of the
SDP library. And then work to support more and more of the library.


% About the Types Graph
Re-using an exisiting major codebase is hard. Production ready code is usually
filled with special cases, performance considerations and other "works for
now"-code. The made this project harder than anticipated. While trying to
understand the Idris code base we produced a dependency graph for the types
used in the front end. This is one advantaged of strictly typed programming
that the types, their dependicies tells us a lot about the code and how it
works. And compared to writte documentation, the compiler guarantees that this
information is up to date.

\newcommand{\pterm}{\textit{PTerm}}
\newcommand{\pdecel}{\textit{PDecl}}
\newcommand{\term}{\textit{Term}}
\newcommand{\tti}{\textit{TT}}

% TODO which
This graph of type dependencies can be found in appendix X. By looking at the
graph it is easy to see which types are central in the implementation and which
are only used peripherally. In figure~\ref{fig:types-crop} we see part of the
graph centered on \textit{Term}.

In the graph we cna clearly see that two of the most central data types are
\textit{PTerm} and \textit{Term}. \textit{PTerm} is the main data type of the
conrete syntax, i.e. what the parser produces. A program is a collection of
declarations \textit{PDecl} which are constructed out of \pterm. \pterm
contains everything which is known at parse-time. This is not enough for the
purpose of our transpiler.

% Idris internals again
The next step of compilation is elaboration and translation to \tti. \term is
the main data type of the \tti language. \tti has fully explicit types. It
contains all the information which is necessary for type-checking. A lot of
useful information is generated in the elaboration.

\textit{TT} is dependtly typed lambda-calculus augmented with algebraic data
types and pattern matching. \textit{TT} is full explicitly typed.~\cite{idris}
\textit{TT} is delibratly kept small to be sure it is correct. It is consisted
of well known parts.

The Idris compilator works in a few big passes. The big passes are themself
compromised of many smaller step. On a high-level the compilator goes through
the following stages: Parsing to PDecl-lang. Elaboration and translation to
\textit{TT}. Type checking. Further compilation to smaller languages. Then
lastly translation to the target, i.e. C or JS usually.
