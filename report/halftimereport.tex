\documentclass[parskip=half]{scrartcl}

\usepackage[style=ieee]{biblatex}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
% \usepackage{parskip}
% \setlength{\parskip}{10pt}
\usepackage{tikz}
\usetikzlibrary{arrows, decorations.markings}
\usepackage{chngcntr}
\counterwithout{figure}{section}
\usepackage{xcolor}
% \usepackage{listings}

\usepackage{idrislang}

\definecolor{mypink}{RGB}{228,77,77}
\lstset{language=Haskell,keywordstyle={\bfseries \color{mypink}}}
% \lstset{language=Idris,keywordstyle={\bfseries \color{mypink}}}
\lstset{literate={
  {->}{$\rightarrow$}{1}
  {=>}{$\Rightarrow$}{1}
}}
\renewcommand{\IdrisKeyword}[1]{{{\bfseries\color{mypink} #1 }}}

\addbibresource{ita.bib}

\lstdefinelanguage{Lambda}{%
  morekeywords={%
    % if,then,else,fix % keywords go here
    where, data
  },%
  morekeywords={[2]int},   % types go here
  otherkeywords={:}, % operators go here
  literate={% replace strings with symbols
    {->}{{$\rightarrow$}}{2}
    {=>}{{$\Rightarrow$}}{2}
    {lambda}{{$\lambda$}}{1}
    {forall}{{$\forall$}}{1}
  },
  basicstyle={\sffamily},
  keywordstyle={\bfseries},
  keywordstyle={[2]\itshape}, % style for types
  keepspaces,
  mathescape % optional
}[keywords,comments,strings]%

\begin{document}

\begin{titlepage}

\centering
{\scshape\LARGE Master's thesis half-time report}

% * Preliminary title.

\vspace{0.5cm}
{\huge\bfseries Source-to-source translation\\ from Idris to Agda
  }

\vspace{2cm}
{\Large Jakob Larsson\\}
\texttt{<jakob@karljakoblarsson.com>}

\vspace{1.0cm}
{\large Supervisor: Patrik Jansson  \\
        Examiner: Nils Anders Danielsson}

% \vspace{1.5cm}
\vspace{1.5cm}

\vfill
{\large \today}

\end{titlepage}

\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Plan for halftime report
% ========================

% Talk about possible verification methods. Pros and cons for each, and how
% feasible they are for use in a MSc thesis. See Wibergh's MSc thesis for
% inspo.

% Talk about differences between Agda and Idris
% Philosphically and technically. And in implementation.

% Problems with how to re-use existing code. Maybe discuss problems with using
% internal interfaces. [TODO gärna med referens till litteraturen]

% Write for someone who is taking the same masters program but may not have
% taken the same electives as you. So someone who has taken, logic in computer
% science, programming language technology and algorithms. But haven't taken AFP
% and types and programming languages. So the basics of a compiler and parser
% is known, and most algorithms used. The reader knows basic functional
% programming and some Haskell. But none of Agda or Idris

% I need to talk about the basics of dependently typed programming, for someone
% with a background in functional programming with algebraic data types (but no
% GADTs) and some logic. So I can just mention Curry-Howard in passing. The
% difference between propositional logic and predicate logic.

% But I need to talk about types parametrizied by values, and not only types.
% And how this relate to theorem proving, difference between Agda/Idris and
% theorem provers such as Coq/Isabelle, a little.  Why is dependently typed
% programming useful? And what are the problems with it?


% Tell about my progress so far:
% ------------------------------
% - Digging in Idris and Agda internals   [bugs found? "bad" design? perhaps refer to Edwin Brady and Idris 2 = Blodwen]
% - Reusing Idris parser and Agda pretty-printer
% - Converting AST-to-AST directly with `ita` [main Idris - to - Agda function]
% - Stats tool, and maybe results from running it

% Short background about Dependently typed programming and the need for it? [Yes - half a page?]
% (leads also to some of the problems: lots of type information needed for the translation
%   challenges in translation "two coupled artefacts": spec + code)

% References:
% -----------
% - Both Idris implementation papers
% - Agda presentation/implementation paper
% - Automatic Agda refactoring thesis maybe? [Definitely]
% - What more? [some SE resource about depencies, legacy code, etc.]

% [perhaps later: Consider what is long term of the learning: not just the code, but the new realisations: advice on moving forward after the project]


% From Canvas:
% ------------

% - In the halftime report you inform your examiner of the current status of your
%   thesis work so she/he can get a picture of the progress.

% - Any significant deviation from the planning report must be stated.

% - The student(s) provide the examiner with a written status report of the
%   project,e.g. a draft of the final reportthat includeswork done so far.
%   This document is usually an extension of the planning report.

% - Often, the written halftime report is combined with a short oral presentation
%   for the examiner (and the supervisor).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
% Comments from NAD. Lite feedback:
% On the planning report.

% * "Agda is mainly focused on automated theorem proving": Snarare
%   "interactive theorem proving".
% Sant, bara att ändra.
%
% * Agda 2.6.0 har nyligen släppts.
% Ja, men det var ju försjutton samma dag som jag bara fokuserade på rapporten.

% * "In Agda there are different levels of Set since the set of types can
%    not be part of itself": Idris använder något liknande:
%     http://docs.idris-lang.org/en/latest/faq/faq.html#does-idris-have-universe-polymorphism-what-is-the-type-of-type
% But it is always infered by the Idris compiler, it can never be specified by
% the user as in Agda.

%
% * "Dependently typed programming is the application of Martin-Löf
%    Intuitionistic Type Theory [3] to practical programming": Det finns
%    andra varianter av typteori.
% Ja, HTT och Cubic tex. Men kanske ändå inpirerat främst av Martin-Löf.
%
% * "However, how to efficiently implement a dependently typed programming
%    language is active research, see for example [6]": Jag undrar varför
%    du valde den referensen. Jag föreslår att du förklarar vad du menar
%    lite tydligare, eller tar bort referensen.
% Bara att ta bort den då.
%
% Är det inget mer jag behöver åtgärda än de kommentarerna är ju allt guld!

%%%%%%%%%%%%%%%%%

%      TODO List
% DONE Decide between translator, transpiler or compiler? Transpiler
% DONE Should I hyphenate type-check and type-checker? Yes
% TODO Have a section about Idris and its major features in the background.
%      I want to talk about mutual blocks, infix etc later.
% TODO And how those features relate to Agda.
%

\section{Introduction}

% * Background to the assignment. Why is it relevant?
Agda~\cite{agda} and Idris~\cite{idris} are two dependently typed programming
languages.  Agda is mainly focused on interactive theorem proving while Idris
prioritizes general purpose programming.  However, while both languages have
different focus, they share most of their features. Their type systems are
similar. They are not equal however. This leads to a lot of duplicated effort
especially when writing libraries, since they can't be used with languages.

We wish to investigate if it is possible to construct a source-to-source
compiler from Idris to Agda. The source-to-source compiler, from here called
transpiler, should handle the common subset of Idris and Agda. The languages
are not the same, so we will not work on features only present in Idris. It
would be a lot more work to correctly translate 100\% of the languages,
certainly to much for a master's thesis. However, since the languages are so
similar, the common subset of features is probably more then enough for
a useful transpiler.
% The translation should handle as large subset of Idris as
% possible, but it is unreasonable to expect to cover 100\% of the language.


This transpiler would allow Idris libraries to be reused in Agda. This would
greatly increase the number of available Agda libraries instantly. And increase
the audience for every new Idris library.  It will also increase the confidence
of a given proof if it is valid in both type systems. It is unlikely that both
type-checkers will have the same bug.

The transpiler should preserve the semantics of the translated program.
Otherwise it would not be a useful tool. However, it is hard to formally verify
that this is the case, especially with an incomplete transpiler. Even if it is
possible to run both the source and the translated program and compare their
output, is hard to prove that it is valid for all possible inputs.

There will not be any consideration for run-time characteristics of the
translated program. An efficient Idris program may well be translated into an
unusably slow Agda program. The run-time of a dependently typed program is not
a well understood subject. And it depends a lot on the internal working of the
compiler, which can change with every new version.


The first challenge is to find the common subset of features for which it is
possible to translate. The task is then to construct a compiler which handles
as much of this subset as possible.
A goal to explore for further projects is to do bidirectional translation
between the languages.


% Should this part be in the final report
% \section{Limitations}
% * Limitations. What should be left out and why?
% This part needs to be improved.
Only translation from Idris to Agda will be considered in this project. We will
target Idris 1.3.1 and Agda 2.6.0. It is not feasible to translate every
language feature and edge case.  The goal is to cover a large subset of Idris
features, but it is hard to give an exact goal.  The translator will built step
by step, supporting a bigger subset of language features for each step. The
translator should be usable early on and then improved.
% progression, and where it's reasonable to land.

% Code which is untranslateable
% should be left as holes, with the source as comments.
% TODO Merge the two following paragraphs
There may be valid Idris code which is impossible to translate to Agda. There
may also be code where the correct translation is application dependent. Those
parts will be left as holes for the user to fill in a reasonable translation in
that specific case.

Where the translator fails we wish to leave holes for the user to provide the
correct translation. The holes must be constructed so that this is possible
which is not obvious to do.



% Dependent records

% Cumutally Set hierarchy. Type in type in Idris.
% Remove since Idris has different levels of Set as well, only it is always
% interfered and cannot be explicitly specified by the programmer.
% In Agda there are different levels of \texttt{Set} since the set of types can
% not be part of itself. This is useful for proofs, but will not be considered in
% this project.

% Automated testing of program output is probably to hard, I need a simpler
% verification criteria.

% Comment from NAD:  Man kan t ex inspektera typsignaturer manuellt och sedan
% förlita sig på att typcheckaren gör sitt jobb (om typsignaturen är
% tillräckligt precis).
% Här är det lite bra input. Det låter som en rimlig start.

\section{Background}

Dependently typed programming is the application of
% Martin-Löf
% TODO
% Maybe mention about other forms of type theories. Agda is explicitly based on
% Martin-Löf, it says so in the first paragraph of the documentation.
% "It is an extension of Martin-Löf’s type theory, and is the latest in the
% tradition of languages developed in the programming logic group at Chalmers."
Intuitionistic Type Theory~\cite{martinlof} to practical programming.  Types
are allowed to depend on values, which allows the compiler to check much richer
properties about the program than Hindley-Milner~\cite{hindley}~\cite{milner}
style types.

Agda and Idris are two widely used dependently type programming languages.
The Idris website states that Idris is inspired
by Agda but with more focus on practical
programming.\footnote{\url{http://docs.idris-lang.org/en/latest/faq/faq.html\#what-are-the-differences-between-agda-and-idris}}
They are similar in features and their type-systems.
% TODO Refer to the Idris paper instead.

Agda is developed as a research language, with the focus on interactive theorem
proving.  An automatic translator form Idris to Agda source code could increase
the usefulness of both languages. The work of implementation of it can give us
greater knowledge of the differences between the type systems. As well as the
strengths and weaknesses of both languages.

\subsection{Dependently Typed Programming}

Dependent types can be seen as an extension to a algebraic type system which
allow types to depend (predicated) on values. I.e. types and values can be
intermixed. A common example is a vector type which is indexed on the length of
the vector. This allows the programmer to encode constraints and invariants in
the type system. For example see the signature for \texttt{head} and
\texttt{tail} below.  For \texttt{head} to type-check it requires a vector of
length less than 1, and can therefore never fail. \texttt{tail} is likewise
known to always return a vector of length minus one. The compiler also
guarantees that the implementation of the functions follow the properties
encoded in the types, other wise they will not compile.  This mixing of values
and types goes both ways, types are values and values are types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO Improve this section. It is maybe unnecessary, and not relay relevant
% to my thesis.

% Dependent types can be used for proof, see Curry-Howard. But also for providing
% strong correctness guarantees. Which is useful for safety critical systems.

% Dependent types can be seen as the next step in the progression.
% \begin{enumerate}
%   \item Algebraic types
%   \item Parametric Algebraic types
%   \item Generalized Algebraic Data Types
%   \item GADTs
%   \item Full Dependent Types
% \end{enumerate}

% Parametric Algebraic types allow for parametric polymorphism, as used in
% Haskell. This means we can write generic functions like:
% \begin{lstlisting}[language=Lambda]
%     forall a => [a] -> [a] -> [a]
% \end{lstlisting}

% Generalized Algebraic data types allow data constructors whose return values
% are parametrized diffrently. In Haskell syntax:

% \begin{lstlisting}[language=Haskell]
% data Expr a where
%   EBool :: Bool -> Expr Bool
%   EInt :: Int -> Expr Int
% \end{lstlisting}

% Compare to Dependent types where the return type is allowed to depend on both
% the type and the \textit{value} of the type variable.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[language=Haskell]
data Vector : Type -> Nat -> Type where
  Nil : {a : Type} -> Vec a 0
  Cons : {a : Type} -> {n : Nat} -> a -> Vector a n -> Vector a (n + 1)

a : Vector Int 10

head : Vector a (Suc n) -> a
tail : Vector a (Suc n) -> Vector a n
\end{lstlisting}

% TODO Talk about parametrized types and indexed types, and their differences.
% It will be useful later, when talking about problems with my implementation.
% Maybe in the Idris subsection.


% TODO No headings with a single paragraph
\subsubsection{Termination}

For dependent types to be decidable and consistent every program needs to
terminate. Otherwise type-checking may take an infinite time.  Both Agda and
Idris requires programs to terminate by default, but the termination check can
be bypassed explicitly. This is needed for some programs, especially
interactive programs, however, it means that the logic is not consistent and
therefore can prove false statements.

% TODO No headings with a single paragraph
\subsection{Source-to-Source translation}
% TODO Write a general introduction about transpilers/source-to-source etc.
% TODO Find relevant articles

A source-to-source compiler, often called a transcompiler or transpiler, is
a compiler which translates source code in one programming language into
another language, usually of similar level of abstraction. A traditional
compiler takes a higher level language as input and outputs a lower level
language, often machine code.  Since Agda and Idris are similar languages we will write a transpiler.


\subsection{The Idris programming language}
% TODO Write about Idris and its major features for the programmer. Especially
% how it differs from theory and Agda.


% TODO Talk about implicit vs. explicit arguments
\subsubsection{Implicit arguments}


% How should this section be in the half-time report?
% A lot of this is already stated earlier in the introduction.
\subsection{Goals}
% Semi-automatic translator is maybe a more correct description.
The goal of this project is to construct a semi-automatic translator which can
translate a subset of Idris into valid Agda. The language features which are
not yet implemented will be left as holes to allow the user to provide the
missing parts.

% I should mention which parts are extra hard. Like: dependent types, records,
% classes/interfaces. Implicit arguments. Maybe partial functions. But I'm not
% sure which parts are yet.

% I should some paper related to transpiling and cite. As well as both Idris and
% Agda implementation-papers. Maybe the faq about differences between the
% languages.

Dependent type systems are still an active research topic, it is not obvious
how to determine if two statements in different systems are equal. This is
a big challenge when trying to show that the transpiler works correctly.  Even
if both the source and translated programs type-check, it does not necessarily
mean the translation is correct.

% How to test and verify to translations? It's not feasible to get a lot
% of code runnable without manual intervention. Can I even get it to type-check?
% And what does it mean just that the code is well typed in both languages.
% Equality is hard, especially with dependent types.
It is not obvious how to verify the translation, ideally the translated
programs both type-check and can be run. Then it would be possible to compare
the outputs are the same. However it is hard enough to get the programs to type
check without manual intervention. The type systems are similar but not
identical. This means that even if both the source and translated program
type-check we can not be sure that they represent the same semantics.
Especially if one of the programs contain holes. It is hard to reason about
equality in the context of dependent types.

\section{Method}
% * Method of accomplishment. How should the work be carried out?
Idris is a large language, we need to build the transpiler in small steps. To
maximise utility of the transpiler we should prioritize the most used features,
and leave more obscure features for later. The first and most important part is
the expression language, function definitions, application and type
declarations.

Usability oriented features are often are implemented as syntactic sugar and
not part of the core language. They are not necessary to implement in a working
transpiler, but are important for it to be a useful tool. There is a trade-off
there we need to make. If the transpiler produces code on the level of
assembly, just encoded in Agda syntax, even if correct, it is not a useful
tool. Since this is meant to be a tool to assist a human programmer it must
work on a level where its simple for a human user to understand the generated
code. It is great if it matches the source closely, but that is not an end in
it self.


Therefore we wrote a tool to capture usage statistics of the top level abstract
syntax tree (AST). The tool show which syntactic constructs are most often
used, and therefore should be prioritized. It also gives the user the
incentive to refactor Idris code which uses less-used language features.
Which may result in cleaner and more easily understood code.

The first step is to translate simple declarations of types and functions,
without dependent types. A subset roughly corresponding to Simply Typed Lambda
Calculus. Since dependent types are the focus of the project the next step is
to translate them. Starting with application in the type level, and functions
definitions. Continuing with indexed data types.

% Maybe Talk about the type language.
% type lang
% base types
% variable
% application t1 t2
% function definition (x : t1) -> t2

% Sum/ simple enumeration T | F
% prod/data P = P Bool Bool

% Indexerad data typer

% Kriteriet for att oversatta eller inte ar inte om det ar latt eller
% svart. Both Idris and Agda are large languages. What features are most
% important to translate?

% Developing from the Idris 1 codebase, utilizing as much of the AST
% and pretty printer from the Agda-source as possible.

\subsection{Implementation details}
We reuse the Idris complier front-end and AST for our implementation. This
makes sure that we are able to parse all Idris code, and we don't have any bugs
in the parser. It could in theory save a lot of time since we don't need to
write a parser. It is however a lot of extra work to reuse real-world code.
Similarly, we reuse the AST and pretty-printer from Agda. This means
that most of the code we need to write is handling the actual translation.

Both Agda and Idris 1 are written in Haskell. This allows us to import both
projects as git submodules, and build them using a common Haskell Stack
project. This makes it easy to reuse all parts of both languages
implementations if needed. The use of Git and submodules makes it explicit what
changes we make to the upstream implementations. Until now we have only made
minor changes, to use the same version of third party libraries in both
Agda and Idris. The use of Git submodules allows us to easily use newer
versions of both languages in the future.

% TODO Maybe this paragraph or the one below is better written than the one
% above.

% Both projects are imported as git submodules in this projects repo, which means
% all changes we have made, to the official implementations are recorded and
% possible to apply again, on updated version. However, we took care to keep the
% modifications minimal to keep the possibility to use the latests versions in
% the future. But since the code depends on a lot of internal interfaces, it will
% still be hard to keep up.

% We pull in both Idris and Agda sources as git submodules in our project
% repository, this makes it possible to record the exact changes we have done to
% the upstream sources. To make it easy to reproduce and extend. It also allows
% use to pull in newer versions of both projects, and the using git rebase, replay
% our changes on top of the newer versions, and make it much easier to maintain
% our tool for future language versions.

% TODO Is there something good in this paragraph?
% Trying to reuse the Agda AST as well has problems. The good thing is that
% Agda is designed to be able to print it's AST back out in the exact same
% representations as the input. However, this means that the parser, AST and
% pretty print has to keep track of a lot of things, not needed for the semantics
% of the program. This made it hard to reconstruct a valid AST from another
% program, we had to guess what parts of the data structure are meaningful or not
% for our use case. And construct dummy data just to keep the compiler
% happy, while not making any difference for the output. We still felt this was
% a reasonable trade off, since constructing a AST and pretty printer from
% scratch would probably be an equal amount of work, but it would be much more
% work to keep it in synch with newer versions of Agda, so the final tool would
% be less useful.





% This is wrong most of it.
% Working step by step, we first translate only simple programs, then adding
% more and more features. Currently unimplemented features are represented with
% holes so that it is always possible to translate code. The output becomes more
% and more complete as the project progresses. The number of holes left for
% a given project also works as an informal method of verification, less holes
% corresponds to a better translator.

To test the implementation we will use the Sequential Decision Problem (SDP)
implementation in
IdrisLibs\footnote{\url{https://gitlab.pik-potsdam.de/botta/IdrisLibs}} which
is one of the bigger Idris codebases available. This will guide our
implementation by first supporting the features used in the core parts of the
SDP library. And then work to support more and more of the library.



% Method
% ------

Ideally we will define a new intermediate language which covers the union of
Agda and Idris features.  This will make clear in the intermediate AST what
features we support and which are not implemented. It also makes it possible to
do bidirectional transpiling in the future.  We could also use QuickCheck to
generate programs in this intermediate language to test the code generation.
This is not done yet.

Language features in the source languages which are not supported in the target
language will either fail the transpiler, as they are not possible to represent
in the intermediate language, or require to be compiled down to simpler
language feature before being translated in to the intermediate. If this is
done it would be helpful for the target language implementers if they would
want to implement that feature in the future.


\subsection{Statistics tool}
In the course of the project we needed a way to prioritize languages features
to implement in the transpiler. Ideally we want the transpiler to handle
as much real-world code as soon as possible. To guide our implementation we
wrote a tool which parses Idris into its AST and then records which data
constructors are most often used.

% TODO
Then we ran this tool on the Idris Prelude. See the results in the table below:


\begin{center}
  \begin{tabular}{ c c c }
    Variable reference     & PTerm: PRef             & 39 \% \\
    Application            & PDecl: PApp             & 26 \% \\
    $\rightarrow$          & PDecl: PPi              & 12 \% \\
    Patten clause          & PDecl: PClauses         & 8 \% \\
    Constant               & PTerm: PConstant        & 4 \% \\
    Type declaration       & PDecl: PTy              & 6 \% \\
                           & PDecl: PImplementation  & 2 \% \\
    Rewrite rule           & PDecl: PRewrite         & 1 \% \\
                           & PDecl: PDirective       & 1 \% \\
                           & PDecl: PPair            & 1 \% \\
    Data declaration       & PDecl: PData            & 0 \% \\
    Fixity declaration     & PDecl: PFix             & 0 \% \\
                           & PTerm: PImpossible      & 0 \% \\
                           & PDecl: PCase            & 0 \% \\
                           & PTerm: PType            & 0 \% \\
                           & PDecl: PInterface       & 0 \% \\
    With-clause            & PClause: PWith          & 0 \% \\
                           & PDecl: PAlternative     & 0 \% \\
                           & PDecl: PConstSugar      & 0 \% \\
                           & PTerm: Placeholder      & 0 \% \\
    Let clause             & PDecl: PLet             & 0 \% \\
    Record declaration     & PDecl: PRecord          & 0 \% \\
    Lambda function        & PDecl: PLam             & 0 \% \\
    Namespace declaration  & PDecl: PNamespace       & 0 \% \\
  \end{tabular}
\end{center}


% We aim to have implementend ?? of the most widely used constructors when this
% project is done.


\subsection{Verification}
It is not obvious how to verify the correctness of the transpiler, especially
while it is a work in progress. It is not feasible to create a 100\% correct
transpiler in the time of this master`s thesis, so we have to somehow verify an
unfinished transpiler.

Even to verify that a single non-trivial program is transpiled correctly is
hard. Since the two languages have slightly different semantics, even a source
and transpiled program pair which seems to be the same for the human
programmer, might have different results for some edge-case. Some possible
verification methods for as single programs, in rough order of difficulty, is
enumerated below:

\begin{enumerate}
\item The program transpiles without errors.
\item The transpiled program type-checks in Agda.
\item Manually inspect that the type signatures are the same.
\item The transpiled program runs without errors.
\item The transpiled program runs with expected output.
\item The source and transpiled programs both returns the same output for
  automatically generated tests.
\item The source and transpiled programs are formally verified to have the same
  semantics.
\end{enumerate}

% \item The transpiler passes generated tests.
% \item The transpiler is formally proved to be correct.

However, we need to show that our transpiler works for different programs.
That rules out some methods which are too manual.  In a perfect world we would
have test suit with a lot of different programs translated and proven correct in
both languages. But no such test suite exists for Agda and Idris.

% TODO This paragraph.
% Ideally we would run both the source and translated program with randomized
% input to automatically test the they return the same result. However, it is
% probably infeasible to get larger programs to type-check and run without manual
% intervention.  Therefore we will use weaker forms of validation.

% TODO This paragraph.
Hopefully we can use the Agda compiler to test if the generated programs
compiles. We can also use this to guide are transpiler, if the final
program does not compile it needs to be re-done. Or the transpiler needs to be
more explicit in that spot. This however require us to keep the source
positions during the translation. Both the Agda and Idris does this, but the
transpiler does not.

To formally prove correctness of the translation is the ideal verification, but
it is far outside the scope of this project, so we will have to settle for less
rigorous methods. It is the safest way, and what would provide full confidence.
But hopefully we can still provide some degree of confidence in the
translation.


% TODO Should I includes some general theory about Dependently typed programming? [Not more than typed lambda calculus]
% TODO Should I write about things which aren't done yet? [as part of an updated plan, yes]

\section{Progress and Results}

We have constructed a transpiler from a subset of Idris to Agda. It handles the
expression language, type signatures and data declarations.  It fails for
implicit argument, which has to be declared in Agda but not in Idris. The
transpiler re-uses both the Idris parser and the Agda pretty-printer from their
main implementations.  This is good, but it has taken time in working with and
around the existing code.  Real-life implementations make a lot of practical
considerations which complicates the code a lot, and are not relevant for this
project.

% We have developed a tool to translate simple Idris programs into Agda. It works
% for a subset of Idris, namely:

% \begin{enumerate}
%   \item Data declarations
%   \item Simple expressions
%   \item And some more things
% \end{enumerate}

The problem of building both project with the same version of GHC and
dependencies took time. It was a manual process of comparing cabal-files and
trying to find versions of dependencies which matches both. And in some cases
change one project to use a more recent version of a dependency with a updated
interface. Idris also uses a custom build process which need some revision to
work in a new folder structure.

% Idris uses a custom build process which was a pain to use with a different
% folder structure. Since we wanted to pull in both Idris and Agda as `git`
% submodules in our repo we needed to change the folder structure and the build
% process. The was maybe not worth the effort.


We have not yet done any verification beyond manual inspection.  But transpiled
programs type-checks in Idris. It is one verification step.  But the goal is
the have a more thorough verification in the end of the project.

% TODO Maybe write something like this.
% In the beginning the process was to run the translation, then try to load the
% program in Agda and see if it compiles. Then manually fix it so that it
% compiles, then changing the transpiler to do the same thing we just did
% manually.

% Implicit arguments are only known and calculated in the elaboration step of
% Idris compilation. There for it is hard to translate them after only parsing.

The transpiler does not handle implicit arguments yet. Agda and Idris have
different type-checkers, Agda requires more explicit definitions. A implicit
argument used have to be defined. Idris automatically considers all lower case
variables in type signatures to be a implicit variable. Since the implicit
arguments in Idris are elaborated in the Type-checker we can not use the parser
output to reconstruct them.  Only after Idris is compiled to the intermediate
language \texttt{tt\_elab} the type-checking and elaboration is run.
% TODO Theese to paragraphs should be fixed and merged and spilt to three maybe

Therefore we need to run the elaboration and then extract the implicit
arguments from the \texttt{tt\_elab} representation before translating them to
Agda.  We are going to do this in a pre-precessing step before the translation,
we translate the \texttt{tt\_elab} back into regular Idris. This makes it
possible the then just use the main transpiler.  This has the side effect of
making that translation useful for a Idris automatic refactoring tool. It is
often useful to change between implicit and explicit arguments when developing
a dependently typed program.

% TODO This is stated above in Method
% \subsubsection{Statistics tool and its results}
% We have a tool which loads Idris files and parser them. It then uses the
% Declaration/Term AST to calculate which languages features are used and how often
% they are used. See some results from IdrisLibs SDP below.

% This was used to guide and prioritize the implementation of the main tool. For
% the most part it matches our intuitive guess. But it gives us a better argument
% for that the transpiler is useful, even though it is unfinished.

% \subsubsection{Implementation difficulties}
% As expected we ran it to a lot of non project related difficulties when trying
% to reuse existing Agda and Idris sources.

% TODO Should this be in the report?
% The Idris compiler implementation uses the state monad a lot.
% It is almost like an imperative program, just written in Haskell. The
% often touted benefits of functional programming goes out of the window, but the
% compiler is still happy. It goes to show that functional programming is not
% a miracle cure for bad programs, that is still up to the programmer.

% Something something about the crazy Idris implementation with a big state
% monad used everywhere. It is almost an imperative program,
% just written in Haskell.

% The next version of Idris is developed from scratch in a new project, and some
% of the reasons for that is the current implantation, and the difficulties in
% working with it.

% Just trying to find the internal interface of the Idris parser took a long
% time.

% \section{Conclusions}

% Nothing right now. Maybe leave this section out for the halftime report.


% Maybe useful things to cite:
% R. Milner "Well-typed programs can't go wrong" (1978)

% ~\cite{coquand1992pattern} % Dependent pattern matching is hard
% ~\cite{{quantitative-type-theory} % Blodwen implementation

% \bibliographystyle{plain}

\newpage
\printbibliography{}

\end{document}

% TODO: check possible half-time presentation
%   https://lists.chalmers.se/mailman/listinfo/proglog
%   https://lists.chalmers.se/mailman/listinfo/fp
